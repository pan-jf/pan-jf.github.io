{"meta":{"title":"七月七日晴","subtitle":"","description":"","author":"pan-jf","url":"https://pan-jf.github.io","root":"/"},"pages":[{"title":"","date":"2022-08-23T09:04:28.577Z","updated":"2022-08-23T09:04:28.577Z","comments":true,"path":"categories/index.html","permalink":"https://pan-jf.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-24T02:57:48.819Z","updated":"2022-08-24T02:57:48.819Z","comments":true,"path":"about/index.html","permalink":"https://pan-jf.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-23T09:04:40.619Z","updated":"2022-08-23T09:04:40.619Z","comments":true,"path":"tags/index.html","permalink":"https://pan-jf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sync包之Once","slug":"golang/sync/2","date":"2022-09-09T09:34:22.000Z","updated":"2022-09-09T09:46:42.428Z","comments":true,"path":"2022/09/09/golang/sync/2/","link":"","permalink":"https://pan-jf.github.io/2022/09/09/golang/sync/2/","excerpt":"","text":"Oncesync.Once 一般用来确保某个动作至多执行一次 普遍用于初始化资源，单例模式 初始化资源type MyBiz struct &#123; once sync.Once &#125; func (m *MyBiz) Init() &#123; m.once.Do(func() &#123; &#125;) &#125; 单例模式 type singleton struct &#123; &#125; var instance *singleton var instanceOnce sync.Once func (s *singleton) InitSingle() &#123; fmt.Println(&quot;I am single,doing init&quot;) &#125; func GetSingleInstance() *singleton &#123; instanceOnce.Do(func() &#123; instance = &amp;singleton&#123;&#125; instance.InitSingle() &#125;) return instance &#125; func TestSingleton(t *testing.T) &#123; GetSingleInstance() GetSingleInstance() GetSingleInstance() GetSingleInstance() &#125; 底层实现 这是一种double-check的变种。 没有直接利用读写锁，而是利用原子操作来扮演锁的角色。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://pan-jf.github.io/categories/Golang/"}],"tags":[{"name":"sync","slug":"sync","permalink":"https://pan-jf.github.io/tags/sync/"}]},{"title":"sync包之Mutex和RWMutex","slug":"golang/sync/1","date":"2022-09-05T12:35:22.000Z","updated":"2022-09-09T09:30:39.851Z","comments":true,"path":"2022/09/05/golang/sync/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/05/golang/sync/1/","excerpt":"","text":"Mutex和RWMutexMutex可以看做是锁，而RWMutex则是读写锁。 一般用法是将Mutex或者RWMutex和需要被保护住的资源封装在一个结构体内 如果有多个goroutine同时读写的资源，就一定要保护起来 如果多个goroutine只读某个资源，则就不需要保护 使用锁的时候，优先使用RWMuteex。 RWMutex核心方法 RLock RUnlock Lock Unlock Mutex核心方法 Lock Unlock 例子：实现map的线程安全的封装 func TestSafeMap(t *testing.T) &#123; var sTest = SafeMap&#123; m: make(map[string]int, 0), mutex: sync.RWMutex&#123;&#125;, &#125; var wg sync.WaitGroup for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go func() &#123; defer wg.Done() for j := 0; j &lt; 100; j++ &#123; sTest.LoadOrStore(fmt.Sprintf(&quot;s_%d&quot;, j), j) // fatal error: concurrent map writes //sTest.NotSafe(fmt.Sprintf(&quot;s_%d&quot;, j), j) &#125; &#125;() &#125; wg.Wait() fmt.Println(sTest.m) &#125; type SafeMap struct &#123; m map[string]int mutex sync.RWMutex &#125; func (s *SafeMap) NotSafe(key string, value int) (val int, loaded bool) &#123; s.m[key] = value return value, false &#125; func (s *SafeMap) LoadOrStore(key string, value int) (val int, loaded bool) &#123; s.mutex.RLock() val, ok := s.m[key] s.mutex.RUnlock() if ok &#123; return val, true &#125; s.mutex.Lock() defer s.mutex.Unlock() val, ok = s.m[key] if ok &#123; return val, true &#125; s.m[key] = value return value, false &#125; 任何非线程安全的类型、接口都可以利用读写锁+装饰器模式无侵入式地改造为线程安全的类型、接口 Mutex细节锁的一般实现都是依赖于： 自旋作为快路径 等待队列作为慢路径 自旋可以通过控制次数或者时间来退出循环 慢路径：跟语言特性有关，有些依赖于操作系统线程调度，如JAVA。有些是自己管，如goroutine 以下是锁实现模板 type Lock struct &#123; state int &#125; func (l *Lock)Lock() &#123; i := 0 // 自旋 for locked = CAS(UN_LOCK,LOCKED); !locked &amp;&amp; i &lt; 10 &#123; i++ &#125; if locked &#123; return &#125; // 将自己的线程加入阻塞队列,等待唤醒 enqueue() &#125; golang mutex锁核心 state就是用来控制锁状态的核心，所谓加锁，就是把state修改为某个值，解锁也是类似 sema用来处理沉睡、唤醒的信号量，依赖于两个runtime调用 runtime_SemacquireMutex: sema加1并且挂起goroutine runtime_Semrelease: sema减1并且唤醒sema上等待的一个goroutine golang mutex加锁细节 一把锁，如果没有人持有它，也没有人抢，那么一次CAS操作就能成功。 在上述锁实现模板中，我们说自旋是快路径。 在golang把它归到了慢路径里面，如图： 实际上，在这个片段中还是很快的，因为没有进入等待队列的环节 所以：理论上的自旋 &#x3D; Go的快路径 + Go慢路径中的自旋部分 后半部分就是控制锁的两种模式，以及进队列，被唤醒的部分了，如图： 在1.18之后， 使用 runtime_Semacquire 替换了 runtime_SemacquireMutex ，后者增加了一些对Mutex分析的功能 控制锁的两种模式 正常模式 饥饿模式 如果一个新的goroutine进来争夺锁，而且队列里面也有等待的goroutine，你是设计者，你会把锁给谁？ 给G2：毕竟我们要保证公平，先到先得是规矩，不能破坏 G1和G2竞争：保证效率，G1肯定已经占着CPU了，所以大概率能拿到锁 所谓的正常模式，就是G1和G2竞争的模式。所以正常模式的核心是避免goroutine调度。 那如果要是每次G2想要拿到锁的时候，都被新来的G1给抢走了，那么G2和其他队列不就是饥饿了吗？ G2每次没抢到锁，都要退回去队列头。 所以如果等待时间超过1ms，那么锁就会变成饥饿模式。 在饥饿模式下，锁会优先选择队列中的goroutine 当队列中只剩下一个goroutine，或者G2的等待时间小于1ms时，将退出饥饿模式 步骤总结 先上来一个CAS操作，如果这把锁正空闲，并且没人抢，那么就直接成功 否则，自旋几次，如果这个时候成功了，也不用加入队列 否则，加入队列 从队列中被唤醒： 正常模式：和新来的一起抢锁，但是大概率失败 饥饿模式：肯定拿到锁 golang mutex解锁细节 上来就是一个 atomic 操作，解锁。理论上来说这也应该是一个CAS操作，即必须是加锁状态才能解锁，Go这种写法效果是一样的 如果解锁失败则步入慢路径，也就是要唤醒等待队列里面的goroutine。因为Go的锁有两种模式，所以有两个分支。 Mutex和RWMutex注意事项 RLock RUnlock 适合于读多写少的场景 写多读少直接加写锁 Lock Unlock 可以考虑使用函数式写法，如延迟初始化 Mutex和RWMutex都是不可重入的 尽可能使用defer来解锁，避免panic（panic是直接中断，如果此时拿着锁是没办法释放掉的，但是defer可以确保释放，即使是panic） sync包Mutex面试要点 Mutex的公平性：Go的锁是不公平锁。为什么它不设计为公平锁？ Mutex的两种模式，以及两种模式的切换时机： 正常模式 饥饿模式 为什么Mutex要设计出来这两种模式？这个问题基本等价于为什么它不设计为公平锁 如果队列里面有goroutine在等待锁，那么新来的goroutine有可能拿到锁吗？当然，而且大概率 Mutex是不是不可重入的锁？显然不是 RWMutex和Mutex有什么区别？如何选择这两个？几乎完全是写操作的选Mutex,其他时候优先选择RWMutex Mutex是怎么做到挂起goroutine的，以及如何唤醒goroutine的？在这个语境下，只需要回答sema这个字段以及runtime_SemacquireMutex和runtime_Semrelease两个调用就可以","categories":[{"name":"Golang","slug":"Golang","permalink":"https://pan-jf.github.io/categories/Golang/"}],"tags":[{"name":"sync","slug":"sync","permalink":"https://pan-jf.github.io/tags/sync/"}]},{"title":"context包底层及面试题","slug":"golang/context/1","date":"2022-09-03T15:07:22.000Z","updated":"2022-09-05T02:07:24.239Z","comments":true,"path":"2022/09/03/golang/context/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/03/golang/context/1/","excerpt":"","text":"包核心方法 context.WithValue 设置键值对，并返回一个新的context实例 context.WithCancel 用于设置链路。 context.WithDeadine 用于设置链路。 context.WithTimeout 用于设置链路。 注意：context实例都是不可变的，每一次都是新创建的。 包核心接口API Deadline 返回过期时间，如果ok为false，说明没有设置过期时间。 Done 返回一个channel，一般用于监听Context实例的信号，比如说过期，或者正常关闭 Err 返回一个错误用于表达Context发生了什么 Canceled表示正常关闭 DeadlineExceeded表示过期超时 Value 取值 context包用途 安全传递数据 控制链路 安全传递数据安全传递数据，是指在请求执行上下文中线程安全地传递数据，依赖于WithValue方法 因为Go本身没有thread-local机制，所以大部分类似的功能都是借助于context来实现的。 实际例子 链路追踪的trace id AB测试的标记位 压力测试的标记位 分库分表中间件中传递 Sharding hint ORM中间件传递SQL hint web框架传递上下文 进程内传递就是依赖于context.Context传递的，也就是意味着所有的方法都必须有context.Context参数 父子关系 当父亲取消或者超时，所有派生的子context都被取消或者超时 当找key的时候，子context先看自己有没有，没有则去祖先里面找 func TestParentCtx(t *testing.T) &#123; ctx := context.Background() dlCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Minute)) childCtx := context.WithValue(dlCtx, &quot;key&quot;, 123) cancel() err := childCtx.Err() fmt.Println(err) &#125; func TestParentValueCtx(t *testing.T) &#123; ctx := context.Background() childCtx := context.WithValue(ctx, &quot;key1&quot;, 123) ccCtx := context.WithValue(childCtx, &quot;key2&quot;, 1234) val := childCtx.Value(&quot;key2&quot;) // 儿子拿不到孙子设置的值 fmt.Println(val) val = ccCtx.Value(&quot;key1&quot;) // 孙子能拿到儿子的值 fmt.Println(val) &#125; 核心方法分析WithValue WithValue底层采用valueCtx存储，可以看到使用key,val分别存储键值信息 典型的装饰器模式 在已有Context的基础上附加一个存储key-value的功能 只能存储一个key,val 为什么不用map？ map要求key是comparable的，而我们可能用不是comparable的key context包的设计理念就是将context设计为不可变 控制方法 WithCancel,WithDeadline,WithTimeout三者都是控制方法，区别在于 没有过期时间，但是又必须在必要的时候取消，使用WithCancel 在固定点过期，使用WithDeadline 在一段时间后过期，使用WithTimeout(其实看底层可以得知，也还是调用了WithDeadline) 使用控制方法后，监听Done()返回的channel，不管是主动调用cancel()还是超时，都可以从这个channel取出数据，并且可以根据Err()判断出属于那种情况 父Context可以控制子Context,反过来不行 func TestContextTimeout(t *testing.T) &#123; bg := context.Background() timeoutCtx, cancel1 := context.WithTimeout(bg, time.Second) // 子context尝试3秒才取消，是没效果的 subCtx, cancel2 := context.WithTimeout(timeoutCtx, 3*time.Second) go func() &#123; // 1秒钟之后就会过期，然后输出timeout &lt;-subCtx.Done() fmt.Println(&quot;timeout&quot;) &#125;() time.Sleep(2 * time.Second) cancel2() cancel1() &#125; 常用方法——控制超时相当于同时监听2个channel，一个是正常业务结束的channel，一个是Done()返回的channel func TestTimeoutExample(t *testing.T) &#123; ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() bsChan := make(chan struct&#123;&#125;) go func() &#123; slowBusiness() bsChan &lt;- struct&#123;&#125;&#123;&#125; &#125;() select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;timeout&quot;) case &lt;-bsChan: fmt.Println(&quot;business end&quot;) &#125; &#125; func slowBusiness() &#123; time.Sleep(2 * time.Second) &#125; 其他方法处理控制超时(不推荐)使用time.AfterFunc控制超时，但实际这种使用会被认为是定时任务，不大像是超时控制 主要有2个弊端： 如果不主动取消，那么AfterFunc是必然会执行的 如果主动取消，那么在业务正常取消到主动取消之间。有一个短的时间差。 func TestTimeoutTimeAfter(t *testing.T) &#123; bsChan := make(chan struct&#123;&#125;) go func() &#123; slowBusiness() bsChan &lt;- struct&#123;&#125;&#123;&#125; &#125;() timer := time.AfterFunc(time.Second, func() &#123; fmt.Println(&quot;timeout&quot;) &#125;) &lt;-bsChan fmt.Println(&quot;business end&quot;) timer.Stop() &#125; DB.conn 控制超时首先检查一次context.Context有没有超时 这种提前检测一下的用法还是比较常见的，比如说RPC链路超时控制就可以先看看context有没有超时 如果超时可以不发送请求，直接返回超时响应 一般来说，超时控制至少两个分支 超时分支 正常业务分支 所以一般context.Context和select case一起使用 errgroup.WithContext使用context传递信号包引入 &quot;golang.org/x/sync/errgroup&quot; withContext会返回一个context.Context实例 如果errgroup.Group的Wait返回，或者任何一个group执行的函数返回Error,context.Context实例都会被取消（一损俱损） 用户可以监听context.Context来判断errgroup.Group的执行情况 这是典型的将context.Context作为信号载体的用法，本质是依赖于channel的特性。 cancelCtx实现cancelCtx也是典型的装饰器模式，在已有Context的基础上，加上取消的功能 核心实现： Done方法是通过类似于 double-check 的机制写的。这种原子操作和锁结合的用法比较罕见 利用children来维护了所有的衍生节点，难点在于如何维护这个衍生节点 children:核心是儿子把自己加进去父亲的children字段里面 但是因为context里面存在非常多的层级，所以父亲不一定是cancelCtx,因此本质上是找属于cancelCtx类型的祖先，然后儿子把自己加进去 cancel就是遍历children，挨个调用cancel，然后儿子调用孙子的cancel，子子孙孙无穷匮也。 timerCtx实现timerCtx也是装饰器模式，在已有cancelCtx的基础上增加了超时的功能 核心实现： 在创建timerCtx的时候，利用time.AfterFunc来实现超时 使用注意事项 一般只用做方法参数，而且是作为第一个参数 所有公共方法，除非是util，helper之类的方法，否则都加上context参数 不要用作结构体字段，除非你的结构体本身也是表达一个上下文的概念 面试要点 context.Context使用场景：上下文传递和超时控制 context.Context原理： 父亲如何控制儿子：通过儿子主动加入到父亲的children里面，父亲只需要遍历就可以 valueCtx和timeCtx的原理","categories":[{"name":"Golang","slug":"Golang","permalink":"https://pan-jf.github.io/categories/Golang/"}],"tags":[{"name":"context","slug":"context","permalink":"https://pan-jf.github.io/tags/context/"}]},{"title":"CPU是在（）结束时响应DMA请求的","slug":"软件设计师/输入输出系统/5","date":"2022-09-02T10:00:00.000Z","updated":"2022-09-02T10:09:15.937Z","comments":true,"path":"2022/09/02/软件设计师/输入输出系统/5/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/5/","excerpt":"","text":"DMA控制方式是在（）之间直接建立数据通路进行数据的交换处理 A、CPU与主存 B、CPU与外设 C、主存与外设 D、外设与外设 解析选C 直接存储器访问（Direct Memory Access,DMA）是指数据在主存与IO设备之间（即主存与外设之间）直接成块传送","categories":[{"name":"输入输出系统","slug":"输入输出系统","permalink":"https://pan-jf.github.io/categories/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"DMA","slug":"DMA","permalink":"https://pan-jf.github.io/tags/DMA/"}]},{"title":"BIOS保存在（）","slug":"软件设计师/输入输出系统/4","date":"2022-09-02T09:49:22.000Z","updated":"2022-09-02T09:57:02.546Z","comments":true,"path":"2022/09/02/软件设计师/输入输出系统/4/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/4/","excerpt":"","text":"在微机系统中，BIOS（基本输入输出系统）保存在（）中 A、主板上的ROM B、CPU的寄存器 C、主板上的RAM D、虚拟存储器 解析选A BIOS（basic input output system）(基本输入输出系统)是一组固化到计算机内主板一个ROM芯片上的程序 它保存这计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序 它可以从CMOS中读写系统设置的具体信息 ROM(Read Only Memory) 只读存储器。只能读出无法写入信息，信息一旦写入就固定了，断电不丢失数据。RAM(Random Access Memory)随机存取存储器。是与CPU直接交换数据的内部存储器，一旦断电数据会丢失。","categories":[{"name":"输入输出系统","slug":"输入输出系统","permalink":"https://pan-jf.github.io/categories/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"BIOS","slug":"BIOS","permalink":"https://pan-jf.github.io/tags/BIOS/"}]},{"title":"浮点数对阶","slug":"软件设计师/计算机基本工作原理/13","date":"2022-09-02T09:23:20.000Z","updated":"2022-09-02T09:36:39.652Z","comments":true,"path":"2022/09/02/软件设计师/计算机基本工作原理/13/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/13/","excerpt":"","text":"浮点数的表示分为阶和尾数两部分。两个浮点数相加时，需要先对阶，即（）（n为阶差绝对值） A、将大阶向小阶对齐，同时将尾数左移n位 B、将大阶向小阶对齐，同时将尾数右移n位 C、将小阶向大阶对齐，同时将尾数左移n位 D、将小阶向大阶对齐，同时将尾数右移n位 解析选D 对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的。 例如1000.2 + 119.3 1000是 1.0002X(10^3) ，其中1.0002是尾数，3是指数，10是基数119是 1.193X(10^2)，其中1.193是尾数，2是指数，10是基数 对阶需要先将 1.193X(10^2) 要转成 0.1193X(10^3)，然后再计算 1.0002 + 0.1193,得出1.1195 X (10^3)","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"浮点数","slug":"浮点数","permalink":"https://pan-jf.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"}]},{"title":"为从内存读取指令操作码，首先要将（）的内容送到地址总线上","slug":"软件设计师/指令系统和计算机体系结构/6","date":"2022-09-02T09:02:22.000Z","updated":"2022-09-02T09:02:01.328Z","comments":true,"path":"2022/09/02/软件设计师/指令系统和计算机体系结构/6/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6/","excerpt":"","text":"计算机在一个指令周期的过程中，为从内存读取指令操作码，首先要将（）的内容送到地址总线上 A、指令寄存器（IR） B、通用寄存器（GR） C、程序计数器（PC） D、状态寄存器（PSW） 解析选C CPU首先从程序计数器（PC）获得需要执行的指令地址， 从内存（或高速缓存）读取到的指令则暂存在指令寄存器（IR），然后进行分析和执行","categories":[{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"程序计数器","slug":"程序计数器","permalink":"https://pan-jf.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"}]},{"title":"主存与cache的地址映射方式","slug":"软件设计师/存储系统/4","date":"2022-09-02T08:05:22.000Z","updated":"2022-09-02T08:12:44.267Z","comments":true,"path":"2022/09/02/软件设计师/存储系统/4/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/4/","excerpt":"","text":"主存与cache的地址映射方式中，（）方式可以实现主存任意一块装入cache中任意位置，只有装满才需要替换 A、全相连 B、直接映射 C、组相连 D、串并联 解析选A 全相连地址映射：主存的任意一块可以映射到cache中的任意一块 直接相连映射：主存中的一块只能映射到cache一个特定的块中 组相连的映射：各区的某一块只能存入缓存的同租号的空间内，但组内各块地址之间则可以任意存放 一般来说，主存到cache之间采用直接相连映射；两个对应的组内部采用全相连映射方式 但本题问的是，哪种方式可以实现主存任意一块装入cache中任意位置,所以应该是全相连","categories":[{"name":"存储系统","slug":"存储系统","permalink":"https://pan-jf.github.io/categories/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"地址映射方式","slug":"地址映射方式","permalink":"https://pan-jf.github.io/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/"}]},{"title":"CPU对其访问速度最快的是（）","slug":"软件设计师/计算机基本工作原理/12","date":"2022-09-02T07:56:22.000Z","updated":"2022-09-02T08:00:27.832Z","comments":true,"path":"2022/09/02/软件设计师/计算机基本工作原理/12/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/12/","excerpt":"","text":"计算机中CPU对其访问速度最快的是（） A、内存 B、Cache C、通用寄存器 D、硬盘 解析选C 计算机系统中的CPU内部对通用寄存器的存储速度是最快的。 其次是cache 内存的存取速度再次 硬盘作为外存是速度最慢的 它们共同组成分级存储体系来解决存储容量、成本和速度之间的矛盾。","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"}]},{"title":"定点整数的最大值为（）","slug":"软件设计师/计算机基本工作原理/11","date":"2022-09-02T07:49:22.000Z","updated":"2022-09-02T07:53:40.964Z","comments":true,"path":"2022/09/02/软件设计师/计算机基本工作原理/11/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/11/","excerpt":"","text":"某机器字长为n，最高位是符号位，其定点整数的最大值为（） A、2^n - 1 B、2^(n-1) - 1 C、2^n D、2^(n-1) 解析选B 机器字长为n，最高位为符号位，则剩余的n-1位用来表示数值，其最大值是这n-1位都为1，也就是2^(n-1)-1","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"字长","slug":"字长","permalink":"https://pan-jf.github.io/tags/%E5%AD%97%E9%95%BF/"}]},{"title":"指令寄存器的位数取决于（）","slug":"软件设计师/计算机基本工作原理/10","date":"2022-09-02T07:36:22.000Z","updated":"2022-09-02T07:41:10.766Z","comments":true,"path":"2022/09/02/软件设计师/计算机基本工作原理/10/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/10/","excerpt":"","text":"指令寄存器的位数取决于（） A、存储器的容量 B、指令字长 C、数据总线的宽度 D、地址总线的宽度 解析选B 指令寄存器是CPU中的关键寄存器，其内容为正在执行的指令，显然其位数取决于指令字长。","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"指令寄存器","slug":"指令寄存器","permalink":"https://pan-jf.github.io/tags/%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8/"}]},{"title":"中断向量可提供（）","slug":"软件设计师/输入输出系统/3","date":"2022-09-02T07:36:22.000Z","updated":"2022-09-02T07:36:41.846Z","comments":true,"path":"2022/09/02/软件设计师/输入输出系统/3/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/3/","excerpt":"","text":"中断向量可提供（） A、IO设备的端口地址 B、所传送数据的起始地址 C、中断服务程序的入口地址 D、主程序的断点地址 解析选C 计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回原程序，这个过程称为中断。 中断是一个非常重要的技术。输入输出设备和主机交换数据、分时操作、实时系统、计算机网络和分布式计算机系统中都要用到这种技术。 为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。","categories":[{"name":"输入输出系统","slug":"输入输出系统","permalink":"https://pan-jf.github.io/categories/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"中断向量","slug":"中断向量","permalink":"https://pan-jf.github.io/tags/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F/"}]},{"title":"循环冗余校验码","slug":"软件设计师/计算机基本工作原理/9","date":"2022-09-02T02:20:22.000Z","updated":"2022-09-02T02:33:17.139Z","comments":true,"path":"2022/09/02/软件设计师/计算机基本工作原理/9/","link":"","permalink":"https://pan-jf.github.io/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/9/","excerpt":"","text":"循环冗余校验码（CRC）利用生成多项式进行编码。设数据位为k位，校验位为r位，则CRC码的格式为（） A、k个数据位之后跟r个校验位 B、r个校验位之后跟k个数据位 C、r个校验位随机加入k个数据位中 D、r个校验位等间隔地加入k个数据位中 解析选A 计算机系统运行时，各个部件之间要进行数据交换，为了确保数据在传送过程中正确无误。 提高硬件电器的可靠性 提高代码的校验能力，包括查错和纠错。 常用的三种校验码：奇偶校验码，海明码和循环冗余校验码 循环冗余校验码广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生r个校验位来进行编码。 编码长度为k+r。CRC的代码格式为","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CRC","slug":"CRC","permalink":"https://pan-jf.github.io/tags/CRC/"}]},{"title":"存储单元计算","slug":"软件设计师/存储系统/3","date":"2022-09-01T11:42:22.000Z","updated":"2022-09-01T09:25:11.320Z","comments":true,"path":"2022/09/01/软件设计师/存储系统/3/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/3/","excerpt":"","text":"内存单元按字节编址，地址0000A000H~0000BFFFH共有（）个存储单元 A、8192K B、1024K C、13K D、8K 解析选D 每个地址编号为一个存储单元（容量为1个字节） 地址区间 0000A000H~0000BFFFH 共有1FFF + 1个地址编号。 1FFF + 1 &#x3D; 2000(16进制) &#x3D; 16^3 * 2 (10进制)&#x3D; 2^(4*3) * 2 - 2^(12+1) &#x3D; 2^13 byte 1个字节： 1k &#x3D; 1024byte &#x3D; 2^10 结果 &#x3D; 2^13 &#x2F; 2^10 &#x3D; 2^(13-10) &#x3D; 2^3 &#x3D; 8k","categories":[{"name":"存储系统","slug":"存储系统","permalink":"https://pan-jf.github.io/categories/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"存储单元","slug":"存储单元","permalink":"https://pan-jf.github.io/tags/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/"}]},{"title":"补码最大表示范围","slug":"软件设计师/计算机基本工作原理/8","date":"2022-09-01T11:23:22.000Z","updated":"2022-09-01T09:05:59.131Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/8/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/8/","excerpt":"","text":"若某计算机采用8位整数补码表示数据，则运算（）将产生溢出 A、-127+1 B、-127-1 C、127+1 D、127-1 解析选C 采用8位补码表示整型数据时，可表示的数据范围为 -128~127，因此进行127+1运算会产生溢出。 最大表示的正整数为 补码 01111111 -&gt; 原码为 2^8-1 &#x3D; 127 最大表示的负整数为 补码 10000000 -&gt; 原码为 -128","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"补码","slug":"补码","permalink":"https://pan-jf.github.io/tags/%E8%A1%A5%E7%A0%81/"}]},{"title":"系统可靠度计算","slug":"软件设计师/系统性能评测和可靠性基础/1","date":"2022-09-01T10:20:22.000Z","updated":"2022-09-01T08:15:40.439Z","comments":true,"path":"2022/09/01/软件设计师/系统性能评测和可靠性基础/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%9F%BA%E7%A1%80/1/","excerpt":"","text":"某计算机系统由下面所示的部件构成，假定每个部件的千小时可靠度都为R，则该系统的千小时可靠度为（） A、R + 2R / 4 B、R + R^2 / 4 C、R(1-(1-R)^2) D、R(1-(1-R)^2)^2 解析选D 由于系统构成串联系统时，其中任何一个子系统失效就足以使系统失效，其可靠度等于各子系统可靠度的乘积。 构成并联系统时，只要有一个子系统正常工作，系统就能正常工作。设每个子系统的可靠性分别以R1,R2, … ,Rn表示，则整个系统的可靠度表达为 R = 1 - (1-R1)(1-R2) ... (1-Rn) 因此，本系统的可靠度计算分以下部分 最左边的为R 中间的为 1 - (1-R)(1-R) &#x3D; 1 - (1-R)^2 右边的为 1 - (1-R)(1-R) &#x3D; 1 - (1-R)^2 串联相乘得出 R(1 - (1-R)^2) ^2","categories":[{"name":"系统性能评测和可靠性基础","slug":"系统性能评测和可靠性基础","permalink":"https://pan-jf.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统可靠度","slug":"系统可靠度","permalink":"https://pan-jf.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E5%BA%A6/"}]},{"title":"CISC和RISC的描述","slug":"软件设计师/指令系统和计算机体系结构/5","date":"2022-09-01T10:16:22.000Z","updated":"2022-09-01T07:46:36.230Z","comments":true,"path":"2022/09/01/软件设计师/指令系统和计算机体系结构/5/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/5/","excerpt":"","text":"以下关于CISC和RISC的叙述中，错误的是（） A、在CISC中，其复杂指令都采用硬布线逻辑来执行 B、采用CIBS技术的CPU，其芯片设计复杂度更高 C、在RISC中，更适合采用硬布线逻辑执行指令 D、采用RISC技术，指令系统中的指令种类和寻址方式更少 解析选A CISC (complex instruction set computer) 复杂指令集计算机，它的基本思想是 进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能 实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂 CISC计算机一般所含的指令数目至少300条以上，有的甚至超过500条 RISC (reduced insstruction set computer) 精简指令集计算机，它的基本思想是 通过减少指令总数和简化指令功能，降低硬件设计的复杂度 指令能单周期执行，并通过优化编译提高指令的执行速度 采用硬布线控制逻辑优化编程程序","categories":[{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"CISC","slug":"CISC","permalink":"https://pan-jf.github.io/tags/CISC/"},{"name":"RISC","slug":"RISC","permalink":"https://pan-jf.github.io/tags/RISC/"}]},{"title":"常将源操作数和结果暂存在（）中","slug":"软件设计师/指令系统和计算机体系结构/4","date":"2022-09-01T09:54:22.000Z","updated":"2022-09-01T07:23:39.960Z","comments":true,"path":"2022/09/01/软件设计师/指令系统和计算机体系结构/4/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4/","excerpt":"","text":"CPU执行算术运算或者逻辑运算时，常将源操作数和结果暂存在（）中 A、程序计数器（PC） B、累加器（AC） C、指令寄存器（IR） D、地址寄存器（AR） 解析选B 程序计数器的作用是保存待读取指令在内存中的地址 累加器是算术逻辑运算单元中用来暂存源操作数和计算结果的寄存器 指令寄存器暂存从内存读取的指令 地址寄存器暂存要访问的内存单元的地址","categories":[{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"累加器","slug":"累加器","permalink":"https://pan-jf.github.io/tags/%E7%B4%AF%E5%8A%A0%E5%99%A8/"}]},{"title":"有符号定点小数","slug":"软件设计师/计算机基本工作原理/7","date":"2022-09-01T09:49:22.000Z","updated":"2022-09-01T07:19:14.485Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/7/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7/","excerpt":"","text":"在程序运行过程中，CPU需要将指令从内存中取出并加以分析和执行。CPU依据（）来区分在内存中以二进制编码形式存放的指令和数据 A、指令周期的不同阶段 B、指令和数据的寻址方式 C、指令操作码的译码结果 D、指令和数据所在的存储单元 解析选A 指令周期是执行一条指令所需要的时间。 一般由若干个机器周期组成。是从取指令、分析指令到执行完所需的全部时间。 CPU执行指令的过程中，根据时序部件发出的时钟信号按部就班进行操作。 在取指令阶段读取的是指令，在分析指令和执行指令时，需要操作数时再去读操作数。","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"指令周期","slug":"指令周期","permalink":"https://pan-jf.github.io/tags/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F/"}]},{"title":"防火墙功能特性","slug":"软件设计师/信息安全和病毒防护/1","date":"2022-09-01T09:43:22.000Z","updated":"2022-09-01T07:50:13.753Z","comments":true,"path":"2022/09/01/软件设计师/信息安全和病毒防护/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%92%8C%E7%97%85%E6%AF%92%E9%98%B2%E6%8A%A4/1/","excerpt":"","text":"以下关于防火墙功能特性的叙述中，不正确的是（） A、控制进出网络的数据包和数据流向 B、提供流量信息的日志和审计 C、隐藏内部IP以及网络结构细节 D、提供漏洞扫描功能 解析选D 防火墙最基本的功能就是控制在计算机网络中，不同信任程度区域间传送的数据流。 防火墙对流经它的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。 隐藏内部细节。 所有的访问都经过防火墙，防火墙就能记录下这些访问并作出日志记录，同事也能提供网络使用情况的统计数据。","categories":[{"name":"信息安全和病毒防护","slug":"信息安全和病毒防护","permalink":"https://pan-jf.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%92%8C%E7%97%85%E6%AF%92%E9%98%B2%E6%8A%A4/"}],"tags":[{"name":"防火墙","slug":"防火墙","permalink":"https://pan-jf.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"VLIW是（）的简称","slug":"软件设计师/指令系统和计算机体系结构/3","date":"2022-09-01T09:35:22.000Z","updated":"2022-09-01T07:06:57.262Z","comments":true,"path":"2022/09/01/软件设计师/指令系统和计算机体系结构/3/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3/","excerpt":"","text":"VLIW是（）的简称 A、复杂指令系统计算机 B、超大规模集成电路 C、单指令流多数据流 D、超长指令字 解析选D VLIW (very long instruction word),超长指令字。 一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度。","categories":[{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"VLIW","slug":"VLIW","permalink":"https://pan-jf.github.io/tags/VLIW/"}]},{"title":"计算机总线系统由（）组成","slug":"软件设计师/计算机基本工作原理/5","date":"2022-09-01T08:55:22.000Z","updated":"2022-09-01T06:27:08.208Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/5/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/5/","excerpt":"","text":"三总线结构的计算机总线系统由（）组成 A、CPU总线、内存总线和IO总线 B、数据总线、地址总线和控制总线 C、系统总线、内部总线和外部总线 D、串行总线、并行总线和PCI总线 解析选B 总线线路可以被归为三类 数据总线 地址总线 控制总线","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"总线","slug":"总线","permalink":"https://pan-jf.github.io/tags/%E6%80%BB%E7%BA%BF/"}]},{"title":"有符号定点小数","slug":"软件设计师/计算机基本工作原理/6","date":"2022-09-01T08:55:22.000Z","updated":"2022-09-01T06:31:34.674Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/6/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/6/","excerpt":"","text":"机器字长为n位的二进制数可以用补码来表示（）不同的有符号定点小数 A、2^n B、2^(n-1) C、2^n - 1 D、2^(n-1) + 1 解析选A 补码本身是带符号位的，补码表示的数字中0是唯一的，不像原码有+0和-0之分。 因此n位进制编码表示 2^n 个不同的数","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"补码","slug":"补码","permalink":"https://pan-jf.github.io/tags/%E8%A1%A5%E7%A0%81/"}]},{"title":"CPU是在（）结束时响应DMA请求的","slug":"软件设计师/输入输出系统/2","date":"2022-09-01T08:55:22.000Z","updated":"2022-09-01T06:38:57.175Z","comments":true,"path":"2022/09/01/软件设计师/输入输出系统/2/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/2/","excerpt":"","text":"CPU是在（）结束时响应DMA请求的 A、一条指令执行 B、一段程序 C、一个时钟周期 D、一个总线周期 解析选D DMA控制器在需要的时候代替CPU作为总线主设备，在不受CPU干预的情况下，控制IO设备与系统主存之间的直接数据传输。 DMA操作占用的资源是系统总线，而CPU并非在整个指令执行期间即指令周期内都会使用总线 故DMA请求的检测点设置在每个机器周期也就是总线周期结束时执行，这样使得总线利用率最高。","categories":[{"name":"输入输出系统","slug":"输入输出系统","permalink":"https://pan-jf.github.io/categories/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"DMA","slug":"DMA","permalink":"https://pan-jf.github.io/tags/DMA/"}]},{"title":"暂存运算结果的寄存器是（）","slug":"软件设计师/计算机基本工作原理/4","date":"2022-09-01T08:53:22.000Z","updated":"2022-09-01T06:58:42.981Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/4/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/4/","excerpt":"","text":"在CPU中，常用来为ALU执行算术逻辑运算提供数据并暂存运算结果的寄存器是（） A、程序计数器 B、状态寄存器 C、通用寄存器 D、累加寄存器 解析选D 在运算器中，累加寄存器是专门存放算术或逻辑运算的一个操作数和运算结果的寄存器，能进行加，减，读出，移位，循环移位和求补等操作。是运算器的主要部分。","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"累加寄存器","slug":"累加寄存器","permalink":"https://pan-jf.github.io/tags/%E7%B4%AF%E5%8A%A0%E5%AF%84%E5%AD%98%E5%99%A8/"}]},{"title":"常见的虚拟存储器由（）两级存储器组成","slug":"软件设计师/存储系统/2","date":"2022-09-01T08:43:22.000Z","updated":"2022-09-01T06:57:30.175Z","comments":true,"path":"2022/09/01/软件设计师/存储系统/2/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2/","excerpt":"","text":"常见的虚拟存储器由（）两级存储器组成 A、主存-辅存 B、主存-网盘 C、cache-主存 D、cache-硬盘 解析选A 在具有层次结构存储器的计算机中，虚拟存储器是为用户提供一个比主存储器大得多的可随机访问的地址空间的技术。 虚拟存储技术使辅助存储器和主存储器密切配合。 对用户来说，好像计算机具有一个比实际主存大得多的主存可供使用，因此成为虚拟存储器。 虚拟存储器的地址称为虚地址或逻辑地址。","categories":[{"name":"存储系统","slug":"存储系统","permalink":"https://pan-jf.github.io/categories/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"存储器","slug":"存储器","permalink":"https://pan-jf.github.io/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"},{"name":"主存","slug":"主存","permalink":"https://pan-jf.github.io/tags/%E4%B8%BB%E5%AD%98/"}]},{"title":"主存地址与cache地址之间的转换工作由（）完成","slug":"软件设计师/存储系统/1","date":"2022-09-01T08:20:22.000Z","updated":"2022-09-01T06:57:41.645Z","comments":true,"path":"2022/09/01/软件设计师/存储系统/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1/","excerpt":"","text":"位于CPU与主存之间的高速缓冲存储器（Cache）用于存放部分主存数据的拷贝，主存地址与cache地址之间的转换工作由（）完成 A、硬件 B、软件 C、用户 D、程序员 解析选A 从cache-主存层次实现的目标看 既要使CPU的访存速度接近于访cache的速度 用户程序提供的运行空间应保持为主存容量大小的存储空间 在采用cache-主存层次的系统中，cache对用户程序而言是透明的。也就是说，用户程序可以不需要知道cache的存在。因此，CPU每次访存时，依然和未使用cache的情况一样，给出的是一个主存地址。 但在cache-主存结构中，CPU首先访问的是cache，并不是主存。为此，需要一种机制将CPU的访主存地址转换成访cache地址，这个处理过程对速度要求非常高，因此其是完全由硬件来完成。","categories":[{"name":"存储系统","slug":"存储系统","permalink":"https://pan-jf.github.io/categories/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"存储器","slug":"存储器","permalink":"https://pan-jf.github.io/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"},{"name":"Cache","slug":"Cache","permalink":"https://pan-jf.github.io/tags/Cache/"},{"name":"主存","slug":"主存","permalink":"https://pan-jf.github.io/tags/%E4%B8%BB%E5%AD%98/"}]},{"title":"将指令中的地址码送入（）","slug":"软件设计师/计算机基本工作原理/3","date":"2022-09-01T08:10:22.000Z","updated":"2022-09-01T06:58:30.191Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/3/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3/","excerpt":"","text":"若某条无条件转移汇编指令采用直接寻址，则该指令的功能是将指令中的地址码送入（） A、程序计数器（PC） B、地址寄存器（AR） C、累加器（AC） D、算术逻辑运算单元（ALU） 解析选A 程序计数器是用于存放下一条指令所在单元地址的地方。 在程序执行前，必须将程序的起始地址，即程序的一条指令所在的内存单元地址送入程序计数器。 当执行命令时，CPU将自动修改程序计数器的内容，即每执行一条指令，程序计数器增加一个量，使其指向下一个待指向的指令。 程序的转移等操作也是通过该寄存器来实现的。 其他选项解析 地址寄存器一般用来保存当前CPU所访问的内存单元的地址，以方便对内存的读写操作。 累加器是专门存放算术或者逻辑运算的一个操作数和运算结果的寄存器 ALU是CPU的执行单元，主要负责运算工作","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"程序计数器","slug":"程序计数器","permalink":"https://pan-jf.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"}]},{"title":"在CPU中用于跟踪指令地址的寄存器是（）","slug":"软件设计师/计算机基本工作原理/2","date":"2022-09-01T06:09:22.000Z","updated":"2022-09-01T06:58:14.940Z","comments":true,"path":"2022/09/01/软件设计师/计算机基本工作原理/2/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2/","excerpt":"","text":"在CPU中用于跟踪指令地址的寄存器是（） A、地址寄存器（MAR） B、数据寄存器（MDR） C、程序计数器（PC） D、指令寄存器（IR） 解析选C 程序计数器是用于存放下一条指令所在单元地址的地方。 在程序执行前，必须将程序的起始地址，即程序的一条指令所在的内存单元地址送入程序计数器。 当执行命令时，CPU将自动修改程序计数器的内容，即每执行一条指令，程序计数器增加一个量，使其指向下一个待指向的指令。 程序的转移等操作也是通过该寄存器来实现的。 因此CPU中跟踪指令地址的是程序计数器（PC）。 其他选项解析 指令寄存器一般是用来保存当前正在执行的一条指令 数据寄存器主要是用来保存操作数和运算结果等信息的，其目的是为了节省读取操作数所需占用总线和访问存储器的时间。 地址寄存器一般用来保存当前CPU所访问的内存单元的地址，以方便对内存的读写操作。","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"程序计数器","slug":"程序计数器","permalink":"https://pan-jf.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"name":"寄存器","slug":"寄存器","permalink":"https://pan-jf.github.io/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"}]},{"title":"输入输出控制方法中，采用（）无需CPU干预","slug":"软件设计师/输入输出系统/1","date":"2022-09-01T05:49:22.000Z","updated":"2022-09-01T06:59:06.390Z","comments":true,"path":"2022/09/01/软件设计师/输入输出系统/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/1/","excerpt":"","text":"在输入输出控制方法中，采用（）可以使得设备与主存间的数据块传送无需CPU干预。 A、程序控制输入输出 B、中断 C、DMA D、总线控制 解析选C 计算机中主机与外设间进行数据传输的输入输出控制方法有程序控制方式、中断方式、DMA等。 程序控制方式在程序控制方式下，由CPU执行程序控制数据的输入输出过程。 中断方式在中断方式下，外设准备好输入数据或接收数据时向CPU发出中断请求信号，则暂停正在执行的任务。若CPU决定响应该请求，则暂停正在执行的任务，转而执行中断服务程序进行数据的输入输出处理，之后再回去执行原来被中断的任务。 DMA在DMA方式下，CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻CPU的负担，可以大大节省系统资源","categories":[{"name":"输入输出系统","slug":"输入输出系统","permalink":"https://pan-jf.github.io/categories/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"DMA","slug":"DMA","permalink":"https://pan-jf.github.io/tags/DMA/"}]},{"title":"为实现程序指令的顺序执行，CPU（）中的值将自动加1","slug":"软件设计师/指令系统和计算机体系结构/2","date":"2022-09-01T05:08:22.000Z","updated":"2022-09-01T06:59:24.450Z","comments":true,"path":"2022/09/01/软件设计师/指令系统和计算机体系结构/2/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2/","excerpt":"","text":"为实现程序指令的顺序执行，CPU（）中的值将自动加1 A、指令寄存器（IR） B、程序计数器（PC） C、地址寄存器（AR） D、指令译码器（ID） 解析选B CPU执行指令过程 当执行一条指令时，先把它从内存取到数据寄存器（DR）中，然后再传送至 指令寄存器（IR）。 指令寄存器（IR）保存当前正在执行的指令,然后再传送至指令译码器（ID）。 为了执行任何给定的指令，指令译码器（ID）对操作码进行译码，并向操作控制器发出具体操作的特定信号。 在操作期间，地址寄存器（AR）用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读写操作完成为止。 为了保证程序指令能够连续地执行下去，程序计数器（PC）来确定下一条指令的地址，所以又称为指令计数器。 程序计数器工作过程 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。 当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1","categories":[{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"程序计数器","slug":"程序计数器","permalink":"https://pan-jf.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"}]},{"title":"以下关于CPU的叙述中，错误的是（）","slug":"软件设计师/指令系统和计算机体系结构/1","date":"2022-09-01T04:43:22.000Z","updated":"2022-09-01T03:53:23.998Z","comments":true,"path":"2022/09/01/软件设计师/指令系统和计算机体系结构/1/","link":"","permalink":"https://pan-jf.github.io/2022/09/01/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1/","excerpt":"","text":"以下关于CPU的叙述中，错误的是（） A、CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制 B、程序计数器PC除了存放指令地址，也可以临时存储算术/逻辑运算结果 C、CPU中的控制器决定计算及运行过程的自动化 D、指令译码器是CPU控制器中的部件 解析选B CPU是计算机的控制中心，主要由运算器、控制器、寄存器组和内部总线等部件组成。 控制器控制器由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成，它是发布命令的“决策机构”。即完成协调和指挥整个计算机系统的操作。 它的主要功能有： 从内存中取出一条指令，并指出下一条指令在内存中的位置 对指令进行编码或者测试，并产生相应的操作控制信号，以便启动规定的动作 指挥并控制CPU、内存和输入输出设备之间数据的流动 程序计数器程序计数器（PC）是专用寄存器，具有寄存信息和计数两种功能，又称为指令计数器。 在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的初始内容即是第一条指令的地址。 执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。 由于大多数指令都是按顺序执行的，因此修改的过程通常只是简单地对PC加1。 当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。","categories":[{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"}]},{"title":"海明检验码——n与k的关系是（）","slug":"软件设计师/计算机基本工作原理/1","date":"2022-08-31T15:30:00.000Z","updated":"2022-09-01T06:57:55.076Z","comments":true,"path":"2022/08/31/软件设计师/计算机基本工作原理/1/","link":"","permalink":"https://pan-jf.github.io/2022/08/31/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1/","excerpt":"","text":"海明检验码是在n个数据位之外增设k个校验位，从而形成一个k+n位的新的码字，使新的码字的码距比较均匀地拉大。n与k的关系是（）A、2^k - 1 &gt;= n + k B、2^n - 1 &lt;= n+k C、n=k D、n-1 &lt;= k 解析：选A 海明码是一种多重（复式）奇偶检错编码。 它将信息用逻辑形式编码，以便能检错和纠错。 用在海明码中的全部传输码字是由原来的信息和附加的奇偶检验位组成的。 每一个这种奇偶位被编在传输码字的特定位置上。 推导并使用长度为n位的码字的海明码，所需步骤如下： 确定最小的校验位数k，将他们记成D1、D2、… 、Dk,每个校验位符合不同的奇偶测试规定。 原有信息和k个校验位一起编成长为n+k位的新码字。选择k检验位（0或者1）需满足必要的奇偶条件。 对所接收的信息作所需的k个奇偶检查。 如果所有的奇偶检查结果均正确，则认为信息无错误。如果发现一个或多个错了，则错误的位由这些检查的结果来唯一地确定。求海明码时的一项基本考虑是确定所需最少的校验位数k。考虑长度为n位的信息，且附加了k个校验位，则所发送的总长度为n+k。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果可以表示为一个k位的二进制，它可以确定最多2^k种不同状态。这些状态中必有一个其所有奇偶测试都是真的，它便是判定信息正确的条件。于是剩下的（2^k-1）种状态，可以用来判断误码的位置，于是导出以下关系：2^k-1&gt;=n+k","categories":[{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"海明检验码","slug":"海明检验码","permalink":"https://pan-jf.github.io/tags/%E6%B5%B7%E6%98%8E%E6%A3%80%E9%AA%8C%E7%A0%81/"}]},{"title":"hexo","slug":"hexo","date":"2022-08-23T03:45:22.000Z","updated":"2022-09-01T02:12:44.733Z","comments":true,"path":"2022/08/23/hexo/","link":"","permalink":"https://pan-jf.github.io/2022/08/23/hexo/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://pan-jf.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://pan-jf.github.io/tags/hexo/"}]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://pan-jf.github.io/categories/Golang/"},{"name":"输入输出系统","slug":"输入输出系统","permalink":"https://pan-jf.github.io/categories/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"name":"计算机基本工作原理","slug":"计算机基本工作原理","permalink":"https://pan-jf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"指令系统和计算机体系结构","slug":"指令系统和计算机体系结构","permalink":"https://pan-jf.github.io/categories/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"存储系统","slug":"存储系统","permalink":"https://pan-jf.github.io/categories/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"},{"name":"系统性能评测和可靠性基础","slug":"系统性能评测和可靠性基础","permalink":"https://pan-jf.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%9F%BA%E7%A1%80/"},{"name":"信息安全和病毒防护","slug":"信息安全和病毒防护","permalink":"https://pan-jf.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%92%8C%E7%97%85%E6%AF%92%E9%98%B2%E6%8A%A4/"},{"name":"hexo","slug":"hexo","permalink":"https://pan-jf.github.io/categories/hexo/"}],"tags":[{"name":"sync","slug":"sync","permalink":"https://pan-jf.github.io/tags/sync/"},{"name":"context","slug":"context","permalink":"https://pan-jf.github.io/tags/context/"},{"name":"DMA","slug":"DMA","permalink":"https://pan-jf.github.io/tags/DMA/"},{"name":"BIOS","slug":"BIOS","permalink":"https://pan-jf.github.io/tags/BIOS/"},{"name":"浮点数","slug":"浮点数","permalink":"https://pan-jf.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"},{"name":"程序计数器","slug":"程序计数器","permalink":"https://pan-jf.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"name":"地址映射方式","slug":"地址映射方式","permalink":"https://pan-jf.github.io/tags/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/"},{"name":"CPU","slug":"CPU","permalink":"https://pan-jf.github.io/tags/CPU/"},{"name":"字长","slug":"字长","permalink":"https://pan-jf.github.io/tags/%E5%AD%97%E9%95%BF/"},{"name":"指令寄存器","slug":"指令寄存器","permalink":"https://pan-jf.github.io/tags/%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"中断向量","slug":"中断向量","permalink":"https://pan-jf.github.io/tags/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F/"},{"name":"CRC","slug":"CRC","permalink":"https://pan-jf.github.io/tags/CRC/"},{"name":"存储单元","slug":"存储单元","permalink":"https://pan-jf.github.io/tags/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/"},{"name":"补码","slug":"补码","permalink":"https://pan-jf.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"系统可靠度","slug":"系统可靠度","permalink":"https://pan-jf.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E5%BA%A6/"},{"name":"CISC","slug":"CISC","permalink":"https://pan-jf.github.io/tags/CISC/"},{"name":"RISC","slug":"RISC","permalink":"https://pan-jf.github.io/tags/RISC/"},{"name":"累加器","slug":"累加器","permalink":"https://pan-jf.github.io/tags/%E7%B4%AF%E5%8A%A0%E5%99%A8/"},{"name":"指令周期","slug":"指令周期","permalink":"https://pan-jf.github.io/tags/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F/"},{"name":"防火墙","slug":"防火墙","permalink":"https://pan-jf.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"VLIW","slug":"VLIW","permalink":"https://pan-jf.github.io/tags/VLIW/"},{"name":"总线","slug":"总线","permalink":"https://pan-jf.github.io/tags/%E6%80%BB%E7%BA%BF/"},{"name":"累加寄存器","slug":"累加寄存器","permalink":"https://pan-jf.github.io/tags/%E7%B4%AF%E5%8A%A0%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"存储器","slug":"存储器","permalink":"https://pan-jf.github.io/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"},{"name":"主存","slug":"主存","permalink":"https://pan-jf.github.io/tags/%E4%B8%BB%E5%AD%98/"},{"name":"Cache","slug":"Cache","permalink":"https://pan-jf.github.io/tags/Cache/"},{"name":"寄存器","slug":"寄存器","permalink":"https://pan-jf.github.io/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"海明检验码","slug":"海明检验码","permalink":"https://pan-jf.github.io/tags/%E6%B5%B7%E6%98%8E%E6%A3%80%E9%AA%8C%E7%A0%81/"},{"name":"hexo","slug":"hexo","permalink":"https://pan-jf.github.io/tags/hexo/"}]}